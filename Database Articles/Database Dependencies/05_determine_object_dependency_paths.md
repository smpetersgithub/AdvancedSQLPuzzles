<img src="https://raw.githubusercontent.com/smpetersgithub/AdvancedSQLPuzzles/main/images/AdvancedSQLPuzzles_image.png" alt="Advanced SQL Puzzles" width="200"/>

# Object Dependency Path Analysis Script

By leveraging the `sys.sql_expression_dependencies` table, this script generates dependency paths to trace object relationships, determine their depth, and identify root nodes.

It automates the process by creating a series of temporary stored procedures. Once set up, you can analyze dependencies by specifying a list of databases and an object name. Since objects may span multiple databases, the script is designed to trace dependencies across all databases provided.

üëç The corresponding scripts for this walkthrough, along with this documentation, are available in the following GitHub repository:    
[üìÇ AdvancedSQLPuzzles ‚Üí Database Dependencies](https://github.com/smpetersgithub/AdvancedSQLPuzzles/tree/main/Database%20Articles/Database%20Dependencies/)

----

### Example Output

Before executing the script, I want to highlight a few key points.

First, we'll review the example output generated by the script.

The examples reference Microsoft‚Äôs `WorldWideImporters` database, which is publicly available online.

For example, here is a dependency path for the stored procedure, `WideWorldImporters.Website.SearchForPeople`.
Given the output, we can determine all objects that the stored procedure references.

üîç Objects are labeled using a four-part naming convention `<server_name>.<schema>.<object_name>.<object_type>`

----

| ID | Path                                                                                                                   | Referenced Object Fullname                           | Referenced Type Desc | Depth |
|----|------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------|----------------------|-------|
| 1  | WideWorldImporters.Website.SearchForPeople.SQL_STORED_PROCEDURE ‚û°Ô∏è WideWorldImporters.Application.People.USER_TABLE   | WideWorldImporters.Application.People.USER_TABLE     | USER_TABLE            | 1    |
| 2  | WideWorldImporters.Website.SearchForPeople.SQL_STORED_PROCEDURE ‚û°Ô∏è WideWorldImporters.Purchasing.Suppliers.USER_TABLE | WideWorldImporters.Purchasing.Suppliers.USER_TABLE   | USER_TABLE            | 1    |
| 3  | WideWorldImporters.Website.SearchForPeople.SQL_STORED_PROCEDURE ‚û°Ô∏è WideWorldImporters.Sales.Customers.USER_TABLE      | WideWorldImporters.Sales.Customers.USER_TABLE        | USER_TABLE            | 1    |


----

We can also determine reverse dependencies.  In this example, we identify all objects that depend on the `Customers` table.

| id  | path                                                                                                                                                                                           | Referencing Object Fullname                                                        | depth |
|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------|-------|
| 1   | WideWorldImporters.Application.FilterCustomersBySalesTerritoryRole.SECURITY_POLICY ‚¨ÖÔ∏è WideWorldImporters.Sales.Customers.USER_TABLE                                                            | WideWorldImporters.Application.FilterCustomersBySalesTerritoryRole.SECURITY_POLICY | 1     |
| 2   | WideWorldImporters.Integration.GetCustomerUpdates.SQL_STORED_PROCEDURE ‚¨ÖÔ∏è WideWorldImporters.Sales.Customers.USER_TABLE                                                                        | WideWorldImporters.Integration.GetCustomerUpdates.SQL_STORED_PROCEDURE             | 1     |
| 3   | WideWorldImporters.Integration.GetOrderUpdates.SQL_STORED_PROCEDURE ‚¨ÖÔ∏è WideWorldImporters.Sales.Customers.USER_TABLE                                                                           | WideWorldImporters.Integration.GetOrderUpdates.SQL_STORED_PROCEDURE                | 1     |
| 4   | WideWorldImporters.Integration.GetSaleUpdates.SQL_STORED_PROCEDURE ‚¨ÖÔ∏è WideWorldImporters.Sales.Customers.USER_TABLE                                                                            | WideWorldImporters.Integration.GetSaleUpdates.SQL_STORED_PROCEDURE                 | 1     |
| 5   | WideWorldImporters.Website.CalculateCustomerPrice.SQL_SCALAR_FUNCTION ‚¨ÖÔ∏è WideWorldImporters.Sales.Customers.USER_TABLE                                                                         | WideWorldImporters.Website.CalculateCustomerPrice.SQL_SCALAR_FUNCTION              | 1     |
| 6   | WideWorldImporters.Website.Customers.VIEW ‚¨ÖÔ∏è WideWorldImporters.Sales.Customers.USER_TABLE                                                                                                     | WideWorldImporters.Website.Customers.VIEW                                          | 1     |
| 7   | WideWorldImporters.Website.InsertCustomerOrders.SQL_STORED_PROCEDURE ‚¨ÖÔ∏è WideWorldImporters.Website.CalculateCustomerPrice.SQL_SCALAR_FUNCTION ‚¨ÖÔ∏è WideWorldImporters.Sales.Customers.USER_TABLE | WideWorldImporters.Website.InsertCustomerOrders.SQL_STORED_PROCEDURE               | 2     |
| 8   | WideWorldImporters.Website.InvoiceCustomerOrders.SQL_STORED_PROCEDURE ‚¨ÖÔ∏è WideWorldImporters.Sales.Customers.USER_TABLE                                                                         | WideWorldImporters.Website.InvoiceCustomerOrders.SQL_STORED_PROCEDURE              | 1     |
| 9   | WideWorldImporters.Website.SearchForCustomers.SQL_STORED_PROCEDURE ‚¨ÖÔ∏è WideWorldImporters.Sales.Customers.USER_TABLE                                                                            | WideWorldImporters.Website.SearchForCustomers.SQL_STORED_PROCEDURE                 | 1     |
| 10  | WideWorldImporters.Website.SearchForPeople.SQL_STORED_PROCEDURE ‚¨ÖÔ∏è WideWorldImporters.Sales.Customers.USER_TABLE                                                                               | WideWorldImporters.Website.SearchForPeople.SQL_STORED_PROCEDURE                    | 1     |

----

### Key Details Before Running the Script

Next, I want to highlight a few key details before we execute the script.

1. Cross-Database Dependencies    
The script can trace dependencies across multiple databases. Pass the list of databases as parameters to capture the full dependency paths.

2. Unknown Dependencies    
Objects with a NULL referencing_id in `sys.sql_expression_dependencies` are not resolved by the script. These are typically stored procedures that reference other procedures using a one-part naming convention. Such objects are labeled as UNKNOWN.  It is generally a good idea to identify and update stored procedures to use two-part naming conventions.

3. Self-Referencing Objects    
Self-referencing objects are removed to prevent infinite loops. They are stored in the table `##self-referencing_objects` for review.  Simply query this table after executing the temporary stored procedures.

-----

### Temporary Stored Procedures Created

The script generates the following global temporary stored procedures. I‚Äôve modularized the logic to improve readability and maintainability.

While I won‚Äôt go into the implementation details here, you can paste the code into a large language model (LLM) to get a high-level summary of each procedure‚Äôs functionality.

```text
##temp_sp_create_tables
##temp_sp_insert_sql_statement
##temp_sp_cursor_insert_sql_expression_dependencies
##temp_sp_cursor_insert_sys_objects
##temp_sp_update_sql_expression_dependencies
##temp_sp_determine_paths
##temp_sp_determine_reverse_paths
```

‚ö†Ô∏è Although these are global temporary procedures, they must be executed within the same session in which they are created. Running them in a new session will result in an error ("String or binary data would be truncated...")

---

### Usage Notes

To execute the stored procedures, you must first run the script to create them and then call the temporary procedures within the same session.

The temporary stored procedures do not need to be created in the same schema as the object you're analyzing. You‚Äôll specify the databases to trace dependencies across. It's common to run this script from the `master` database.

#### Example Execution

```sql
-- Declare the target database(s)
DECLARE @v_database VARCHAR(100) = '''WideWorldImporters''';
PRINT('Ensure the string has single quotes around each value: ' + @v_database);

-- Create and populate working tables
EXECUTE ##temp_sp_create_tables @v_database;
EXECUTE ##temp_sp_insert_sql_statement;
EXECUTE ##temp_sp_cursor_insert_sql_expression_dependencies;
EXECUTE ##temp_sp_cursor_insert_sys_objects;
EXECUTE ##temp_sp_update_sql_expression_dependencies;

-- Analyze dependency paths
DECLARE @v_object_name VARCHAR(100) = 'SearchForPeople';
EXECUTE ##temp_sp_determine_paths @v_object_name;

-- Analyze reverse dependency paths
DECLARE @v_object_name_reverse_path VARCHAR(100) = 'Customers';
EXECUTE ##temp_sp_determine_reverse_paths @v_object_name_reverse_path;
```

---

When passing the list of databases, ensure proper formatting so the dynamic SQL can parse the values correctly.

#### Single Database Example

```sql
DECLARE @v_database VARCHAR(100) = '''WideWorldImporters''';
PRINT('Ensure this string is correct: ' + @v_database);
```

#### Multiple Databases Example

```sql
DECLARE @v_database VARCHAR(100) = '''WideWorldImporters'',''AdventureWorksDW''';
PRINT('Ensure the string has single quotes around each value: ' + @v_database);
```

#### Selecting a Dependency Path Procedure

Use one of the following stored procedures based on the direction of analysis. You‚Äôll need to pass the target object as a parameter:

* `##temp_sp_determine_paths` ‚Äì Traces downstream dependencies (what the object depends on)
* `##temp_sp_determine_reverse_paths` ‚Äì Traces upstream dependencies (what depends on the object)

---

#### Current Limitation

The script currently resolves dependencies for one object at a time, not for all objects within a database. Running dependency chains across all objects is computationally intensive and may take several hours to complete.

If you need a full dependency map for an entire database, consider modifying `##temp_sp_determine_paths` to:

1. Retrieve all objects within the target database.
2. Loop through each object, calculating its object dependency path individually.

Additionally, if the specified object name exists in multiple schemas, each instance will be included in the output. You will need to manually identify the correct object.

These limitations are planned to be addressed in future versions of the script.

---

### SQL Script

And now, without further ado, here is the script to generate database dependency paths.  This script is also located in the GitHub repository.

```sql
/*
üìã Instructions

https://github.com/smpetersgithub/AdvancedSQLPuzzles/tree/main/Database%20Articles/Database%20Dependencies

1. Create the temporary stored procedures
2. Set the variables
3. Execute the stored procedures in the same session.

--------------------------------------------------------
--------------------------------------------------------

Please use the following to execute the stored procedures.

-------
--DECLARE @v_database VARCHAR(100) = '''WideWorldImporters'',''AdventureWorksDW''';  --Multiple databases example declaration
DECLARE @v_database VARCHAR(100) = '''WideWorldImporters''';
PRINT('Ensure the stings has single quotes around each value: ' + @v_database)
-------

EXECUTE ##temp_sp_create_tables @v_database;
EXECUTE ##temp_sp_insert_sql_statement;
EXECUTE ##temp_sp_cursor_insert_sql_expression_dependencies;
EXECUTE ##temp_sp_cursor_insert_sys_objects;
EXECUTE ##temp_sp_update_sql_expression_dependencies;

-------
DECLARE @v_object_name VARCHAR(100) = 'SearchForPeople';
EXECUTE ##temp_sp_determine_paths @v_object_name;
-------
DECLARE @v_object_name_reverse_path VARCHAR(100) = 'Customers';
EXECUTE ##temp_sp_determine_reverse_paths @v_object_name_reverse_path;
-------

*/

USE [master];
GO

SET NOCOUNT ON; SET ANSI_WARNINGS OFF;
GO

CREATE OR ALTER PROCEDURE ##temp_sp_create_tables (@vdatabaselist VARCHAR(1000)) AS
BEGIN

    -- Drop temporary tables if they exist
    DROP TABLE IF EXISTS ##databases;
    DROP TABLE IF EXISTS ##sql_statement;
    DROP TABLE IF EXISTS ##sql_expression_dependencies;
    DROP TABLE IF EXISTS ##self_referencing_objects;
    DROP TABLE IF EXISTS ##sys_objects;
    DROP TABLE IF EXISTS ##path;
    DROP TABLE IF EXISTS ##path_list;
    DROP TABLE IF EXISTS ##path_list_final;

    CREATE TABLE ##databases (
        database_id INT PRIMARY KEY,
        [database_name] VARCHAR(128)
    );

    --SELECT * FROM ##databases;

    DECLARE @v_sql_statement NVARCHAR(MAX);
    SET @v_sql_statement = REPLACE('INSERT INTO ##databases (database_id, [database_name]) SELECT database_id, [name] FROM sys.databases WHERE NAME IN (<DATABASE_STRING>);','<DATABASE_STRING>', @vDatabaseList);
    PRINT(@v_sql_statement);
    EXEC sp_executesql @v_sql_statement;


    -----------------------------------------------------------------------
    -- Create a table to store dependencies across databases
    CREATE TABLE ##sql_expression_dependencies 
    (
        sql_expression_dependencies_id INT IDENTITY(1,1) PRIMARY KEY,
        referencing_id                 INT NOT NULL,
        referencing_database_name      VARCHAR(128),
        referencing_schema_name        VARCHAR(128),
        referencing_object_name        VARCHAR(128),
        referencing_type_desc          VARCHAR(128),
        referenced_id                  INT,
        referenced_database_name       VARCHAR(128),
        referenced_schema_name         VARCHAR(128),
        referenced_object_name         VARCHAR(128),
        referenced_type_desc           VARCHAR(128),
        depth                          INT,
        referencing_object_fullname    VARCHAR(128),
        referenced_object_fullname     VARCHAR(128),
        referencing_minor_id           INT,
        referencing_class_desc         VARCHAR(128),
        is_schema_bound_reference      INT,
        referenced_class               INT,
        referenced_class_desc          VARCHAR(128),
        referenced_server_name         VARCHAR(128),
        referenced_minor_id            INT,
        is_caller_dependent            INT,
        is_ambiguous                   INT

    );

    CREATE TABLE ##self_referencing_objects 
    (
        sql_expression_dependencies_id INT,
        referencing_id                 INT NOT NULL,
        referencing_database_name      VARCHAR(128),
        referencing_schema_name        VARCHAR(128),
        referencing_object_name        VARCHAR(128),
        referencing_type_desc          VARCHAR(128),
        referenced_id                  INT,
        referenced_database_name       VARCHAR(128),
        referenced_schema_name         VARCHAR(128),
        referenced_object_name         VARCHAR(128),
        referenced_type_desc           VARCHAR(128),
        depth                          INT,
        referencing_object_fullname    VARCHAR(100),
        referenced_object_fullname     VARCHAR(100),
        referencing_minor_id           INT,
        referencing_class_desc         VARCHAR(128),
        is_schema_bound_reference      INT,
        referenced_class               INT,
        referenced_class_desc          VARCHAR(128),
        referenced_server_name         VARCHAR(128),
        referenced_minor_id            INT,
        is_caller_dependent            INT,
        is_ambiguous                   INT
    );

    CREATE TABLE ##sys_objects (
        [object_id]     INT NOT NULL,
        [database_name] VARCHAR(128),
        [schema_name]   VARCHAR(128),
        [object_name]   VARCHAR(128),
        [type_desc]     VARCHAR(128),
        CONSTRAINT PK_sys_objects PRIMARY KEY ([object_id], [database_name])
        );
    
    CREATE TABLE ##path (
        path_id                     INT IDENTITY(1,1) PRIMARY KEY,
        referencing_object_name     VARCHAR(128) NULL,
        referencing_object_fullname VARCHAR(128) NULL,
        referenced_object_name      VARCHAR(128) NULL,
        referenced_object_fullname  VARCHAR(128) NULL,
        referenced_type_desc        VARCHAR(128) NULL
    );
    
    CREATE TABLE ##path_list (
        path_list_id                INT NOT NULL,
        path                        VARCHAR(1000) PRIMARY KEY NOT NULL,
        referencing_object_fullname VARCHAR(128) NULL,
        referenced_object_fullname  VARCHAR(128) NULL,
        referenced_type_desc        VARCHAR(128) NULL
    );
    
    DROP TABLE IF EXISTS ##path_list_final;
    CREATE TABLE ##path_list_final (
        id                         INTEGER IDENTITY(1,1) PRIMARY KEY,
        [path]                     VARCHAR(4000) NOT NULL,
        referenced_object_fullname VARCHAR(128) NULL,
        referenced_type_desc       VARCHAR(128) NULL
    );
      
    -- 1. Core dependency lookup index
    CREATE INDEX IX_sql_expression_dependencies_referencing_referenced 
    ON ##sql_expression_dependencies (referencing_object_fullname, referenced_object_fullname) 
    INCLUDE (referencing_id, referenced_id);
    
    -- 2. paths table lookup index  
    CREATE INDEX IX_paths_referencing_referenced
    ON ##path (referencing_object_fullname, referenced_object_fullname)
    INCLUDE (referencing_object_name);
    
    -- 3. pathsList processing index
    CREATE INDEX IX_pathslist_path_list_id_path
    ON ##path_list (path)
    INCLUDE (referencing_object_fullname, referenced_object_fullname, referenced_type_desc);
    
    CREATE NONCLUSTERED INDEX IX_path_list_path_desc
    ON ##path_list (path, referenced_type_desc);

    -- 4. Object lookup index
    CREATE INDEX IX_sys_objects_lookup
    ON ##sys_objects ([database_name], [schema_name], [object_name], [object_id])
    INCLUDE ([type_desc]);
    
    -- 5. Dependency updates index
    CREATE INDEX IX_sql_expression_dependencies_referenced_id
    ON ##sql_expression_dependencies (referenced_id, referencing_database_name);

END;
GO

CREATE OR ALTER PROCEDURE ##temp_sp_insert_sql_statement
AS
BEGIN

    
    SELECT id, rowid, sqlline
    INTO   ##sql_statement
    FROM (VALUES
    -----------------------------------------------
    (1, 10, 'WITH cte_sql_expression_dependencies AS'),
    (1, 20, '('),
    (1, 30, 'SELECT *'),
    (1, 40, 'FROM   vdatabase_name.sys.sql_expression_dependencies'),
    (1, 50, 'WHERE  1=1'), 
    (1, 60, ')'),
    -----------------------------------------------
    (1, 70, 'INSERT INTO ##sql_expression_dependencies ('),
    ----------------
    (1, 80, 'referencing_id,'),
    (1, 90, 'referencing_database_name,'),
    (1, 100, 'referencing_schema_name,'),
    (1, 110, 'referencing_object_name,'),
    (1, 120, 'referencing_type_desc,'),

    (1, 130, 'referenced_database_name,'),
    (1, 140, 'referenced_schema_name,'),
    (1, 150, 'referenced_object_name,'),
    (1, 160, 'referenced_id,'),

    (1, 161, 'referencing_minor_id,'),
    (1, 162, 'referencing_class_desc,'),
    (1, 163, 'is_schema_bound_reference,'),
    (1, 164, 'referenced_class,'),
    (1, 165, 'referenced_class_desc,'),
    (1, 166, 'referenced_server_name,'),
    (1, 167, 'referenced_minor_id,'),
    (1, 168, 'is_caller_dependent,'),
    (1, 169, 'is_ambiguous'),
    (1, 170, ')'),
    -----------------------------------------------
    (1, 180, 'SELECT'),
    (1, 190, 'd.referencing_id,'),
    (1, 200, 'DB_NAME(vdatabase_id) AS referencing_database_name,'),
    (1, 210, 's.[name] AS referencing_schema_name,'),    
    (1, 220, 'o.name AS referencing_object_name,'),
    (1, 230, 'o.type_desc AS referencing_type_desc,'),
    (1, 240, 'd.referenced_database_name,'),
    (1, 250, 'd.referenced_schema_name,'),
    (1, 260, 'd.referenced_entity_name,'),
    (1, 270, 'd.referenced_id,'),
    (1, 271, 'referencing_minor_id,'),
    (1, 272, 'referencing_class_desc,'),
    (1, 273, 'is_schema_bound_reference,'),
    (1, 274, 'referenced_class,'),
    (1, 275, 'referenced_class_desc,'),
    (1, 276, 'referenced_server_name,'),
    (1, 277, 'referenced_minor_id,'),
    (1, 278, 'is_caller_dependent,'),
    (1, 279, 'is_ambiguous'),
    -----------------------------------------------
    (1, 280, 'FROM'),
    (1, 290, 'cte_sql_expression_dependencies d'),
    (1, 300, 'INNER JOIN vdatabase_name.sys.objects o ON d.referencing_id = o.object_id'),
    (1, 310, 'INNER JOIN vdatabase_name.sys.schemas s ON o.schema_id = s.schema_id;'),
    -----------------------------------------------
    (2, 10, 'INSERT INTO ##sys_objects (object_id, database_name, schema_name, object_name, type_desc)'),
    (2, 20,  'SELECT'),
    (2, 25,  'o.object_id,'),
    (2, 30,  '''vdatabase_name'','),
    (2, 40,  's.name AS schema_name,'),
    (2, 50,  'o.name AS object_name,'),
    (2, 60,  'type_desc'),
    (2, 70,  'FROM vdatabase_name.sys.objects o INNER JOIN'),
    (2, 80,  'vdatabase_name.sys.schemas s ON o.schema_id = s.schema_id'),
    (2, 90,  'WHERE is_ms_shipped = 0;')
    ) AS a(id, RowID, SQLLine);

/***********************************************************************************
SELECT  REPLACE(REPLACE(sqlline, 'vdatabase_name', 'QA07_Greg'),'vdatabase_id','') 
FROM    ##sql_statement
WHERE   id = 1
***********************************************************************************/
END;
GO

CREATE OR ALTER PROCEDURE ##temp_sp_cursor_insert_sql_expression_dependencies AS
BEGIN
    -- Declare variables
    DECLARE @v_database_id INT;
    DECLARE @v_database_name NVARCHAR(128);
    DECLARE @v_sql_statement NVARCHAR(MAX);

    -- Declare the cursor
    DECLARE mycursor CURSOR FOR SELECT database_id, [database_name] FROM ##databases;

    -- Open the cursor
    OPEN mycursor;

    -- Fetch the first row
    FETCH NEXT FROM mycursor INTO @v_database_id, @v_database_name;

    -- Loop through the cursor
    WHILE @@FETCH_STATUS = 0
    BEGIN

        -- Construct dynamic SQL statement for dependency analysis
        SELECT @v_sql_statement = STRING_AGG(sqlline, ' ')
        FROM   ##sql_statement
        WHERE  ID = 1;
        
        -- Replace placeholders in the SQL statement
        SET @v_sql_statement = REPLACE(@v_sql_statement, 'vdatabase_name', @v_database_name);
        SET @v_sql_statement = REPLACE(@v_sql_statement, 'vdatabase_id', CAST(@v_database_id AS NVARCHAR));
        
        -- Execute the dynamic SQL
        EXEC sp_executesql @v_sql_statement;

        -- Fetch the next row
        FETCH NEXT FROM mycursor INTO @v_database_id, @v_database_name;
    END;

    -- Close and deallocate the cursor
    CLOSE mycursor;
    DEALLOCATE mycursor;

END;
GO

CREATE OR ALTER PROCEDURE ##temp_sp_cursor_insert_sys_objects AS
BEGIN
    -- Declare variables
    DECLARE @v_database_id INT;
    DECLARE @v_database_name NVARCHAR(128);
    DECLARE @v_sql_statement NVARCHAR(MAX);

    -- Declare the cursor
    DECLARE mycursor CURSOR FOR 
    SELECT database_id, [database_name]
    FROM   ##databases;

    -- Open the cursor
    OPEN mycursor;

    -- Fetch the first row
    FETCH NEXT FROM mycursor INTO @v_database_id, @v_database_name;

    -- Loop through the cursor
    WHILE @@FETCH_STATUS = 0
    BEGIN

        -- Construct dynamic SQL statement for dependency analysis
        SELECT @v_sql_statement = STRING_AGG(sqlline, ' ') 
        FROM   ##sql_statement 
        WHERE  ID = 2;

        -- Replace placeholders in the SQL statement
        SET @v_sql_statement = REPLACE(@v_sql_statement, 'vdatabase_name', @v_database_name);
        SET @v_sql_statement = REPLACE(@v_sql_statement, 'vdatabase_id', CAST(@v_database_id AS NVARCHAR));

        -- Execute the dynamic SQL
        EXEC sp_executesql @v_sql_statement;

        -- Fetch the next row
        FETCH NEXT FROM mycursor INTO @v_database_id, @v_database_name;
    END;

    -- Close and deallocate the cursor
    CLOSE mycursor;
    DEALLOCATE mycursor;
END;
GO

CREATE OR ALTER PROCEDURE ##temp_sp_update_sql_expression_dependencies AS
BEGIN

SET NOCOUNT ON;


-- determine object_types for cross-database dependencies
UPDATE ##sql_expression_dependencies
SET    referenced_id = o.[object_id],
       referenced_type_desc = o.[type_desc]
FROM   ##sql_expression_dependencies db INNER JOIN
       ##sys_objects o ON
           CONCAT('.',db.referenced_database_name, db.referenced_schema_name, db.referenced_object_name)
           =
           CONCAT('.',o.[database_name], o.[schema_name], o.[object_name])
WHERE  db.referenced_database_name IS NOT NULL AND
       db.referenced_schema_name IS NOT NULL;
PRINT('Update Statement - Count of cross-database dependencies: ' + CAST(@@ROWCOUNT AS VARCHAR(1000)));

-- determine object_types for referenced_objects
UPDATE ##sql_expression_dependencies
SET    referenced_id = o.[object_id],
       referenced_type_desc = o.[type_desc],
       referenced_database_name = o.[database_name],
       referenced_schema_name = o.[schema_name]
FROM   ##sql_expression_dependencies db INNER JOIN
       ##sys_objects o ON db.referenced_id = o.[object_id] AND db.referencing_database_name = o.[database_name];
PRINT('Update Statement - Count of object_types for referenced_objects: ' + CAST(@@ROWCOUNT AS VARCHAR(1000)));

-- remove self-referencing objects
-- Most of these will be indexes
DELETE ##sql_expression_dependencies
OUTPUT DELETED.* INTO ##self_referencing_objects
WHERE  referenced_id = referencing_id;
PRINT('Delete Statement - Count of self-referencing objects: ' + CAST(@@ROWCOUNT AS VARCHAR(1000)));

INSERT INTO ##sql_expression_dependencies
(
referencing_id,
referencing_type_desc,
referencing_database_name,
referencing_schema_name,
referencing_object_name,
depth
)
SELECT [object_id],
       [type_desc],
       [database_name],
       [schema_name],
       [object_name],
       1 AS depth
FROM   ##sys_objects
WHERE  [object_id] NOT IN (SELECT referencing_id FROM ##sql_expression_dependencies);


UPDATE ##sql_expression_dependencies
SET    referenced_object_fullname = CONCAT_WS('.',referenced_database_name, referenced_schema_name, referenced_object_name, ISNULL(referenced_type_desc,'UNKNOWN')),
       referencing_object_fullname = CONCAT_WS('.',referencing_database_name, referencing_schema_name, referencing_object_name, ISNULL(referencing_type_desc,'UNKNOWN'));
PRINT('Update Statement - Update referenced_object_fullname and referencing_object_fullname columns: ' + CAST(@@ROWCOUNT AS VARCHAR(1000)));


END;
GO

CREATE OR ALTER PROCEDURE ##temp_sp_determine_paths (@v_object_name VARCHAR(1000)) AS
BEGIN

    TRUNCATE TABLE ##path;
    TRUNCATE TABLE ##path_list;
    TRUNCATE TABLE ##path_list_final;

    INSERT INTO ##path (referencing_object_name, referencing_object_fullname, referenced_object_name, referenced_object_fullname, referenced_type_desc)
    SELECT DISTINCT
           referencing_object_name,
           referencing_object_fullname,
           referenced_object_name,
           (CASE referenced_object_fullname WHEN 'UNKNOWN' THEN NULL ELSE referenced_object_fullname END) AS referenced_object_fullname,
           referenced_type_desc
    FROM   ##sql_expression_dependencies;

    INSERT INTO ##path_list (path_list_id, path, referencing_object_fullname, referenced_object_fullname, referenced_type_desc)
    SELECT  1 AS path_list_id,
            CONCAT(referencing_object_fullname,',',referenced_object_fullname) AS path,
            referencing_object_fullname,
            referenced_object_fullname,
            referenced_type_desc
    FROM    ##path
    WHERE   1=1 
            AND referencing_object_name = @v_object_name
            AND referenced_object_fullname IS NOT NULL;
    
    DECLARE @v_row_count INTEGER = 1;
    DECLARE @v_path_list_id INTEGER = 2;
    
    WHILE @v_row_count >= 1
    BEGIN
         WITH cte_determine_referenced_object AS
         (
         SELECT   path,
                  REVERSE(SUBSTRING(REVERSE(path),0,CHARINDEX(',',REVERSE(path)))) AS referenced_object_fullname,
                  referenced_type_desc
         FROM    ##path_list
         WHERE   path_list_id = @v_path_list_id - 1
         )
         INSERT INTO ##path_list (path_list_id, path, referencing_object_fullname, referenced_object_fullname, referenced_type_desc)
         SELECT  @v_path_list_id,
                 CONCAT(a.path,',',b.referenced_object_fullname),
                 a.referenced_object_fullname,
                 b.referenced_object_fullname,
                 b.referenced_type_desc
         FROM    cte_determine_referenced_object a
         INNER JOIN ##path b ON a.referenced_object_fullname = b.referencing_object_fullname
                 AND b.referenced_object_fullname IS NOT NULL
                 AND CHARINDEX(b.referenced_object_fullname, a.path) = 0;

         SET @v_row_count = @@ROWCOUNT;
         PRINT('@v_row_count: ' + CAST(@v_row_count AS VARCHAR(1000)));

         SET @v_path_list_id = @v_path_list_id + 1;

    END;

    INSERT INTO ##path_list_final (path, referenced_object_fullname, referenced_type_desc)
    SELECT  path,
            referenced_object_fullname,
            referenced_type_desc
    FROM    ##path_list r1
    WHERE   1=1 AND
            NOT EXISTS (
                SELECT 1 FROM ##path_list r2
                WHERE r2.path LIKE r1.path + ',%');

    DROP TABLE IF EXISTS ##path_list_rpt;

    SELECT id,
           REPLACE(path,',',N'   ‚û°Ô∏è   ') AS path,
           referenced_object_fullname,
           referenced_type_desc,
           (LEN(path) - LEN(REPLACE(path, ',', ''))) / LEN(',') AS depth
    INTO   ##path_list_rpt
    FROM   ##path_list_final;

    SELECT * FROM ##path_list_rpt;

END
GO

CREATE OR ALTER PROCEDURE ##temp_sp_determine_reverse_paths (@v_object_name VARCHAR(1000)) AS
BEGIN

    TRUNCATE TABLE ##path;
    TRUNCATE TABLE ##path_list;
    TRUNCATE TABLE ##path_list_final;

    INSERT INTO ##path (referencing_object_name, referencing_object_fullname, referenced_object_name, referenced_object_fullname, referenced_type_desc)
    SELECT DISTINCT
           referencing_object_name,
           referencing_object_fullname,
           referenced_object_name,
           (CASE referenced_object_fullname WHEN 'UNKNOWN' THEN NULL ELSE referenced_object_fullname END) AS referenced_object_fullname,
           referenced_type_desc
    FROM   ##sql_expression_dependencies;

    INSERT INTO ##path_list (path_list_id, path, referencing_object_fullname, referenced_object_fullname, referenced_type_desc)
    SELECT  1 AS path_list_id,
            CONCAT(referencing_object_fullname,',',referenced_object_fullname) AS path,
            referencing_object_fullname,
            referenced_object_fullname,
            referenced_type_desc
    FROM    ##path
    WHERE   1=1
            AND referenced_object_name = @v_object_name
            AND referencing_object_fullname IS NOT NULL;

    DECLARE @v_row_count INTEGER = 1;
    DECLARE @v_path_list_id INTEGER = 2;

    WHILE @v_row_count >= 1
    BEGIN
         WITH cte_determine_referencing_object AS
         (
         SELECT   path,
                  SUBSTRING(path, 1, CHARINDEX(',', path) - 1) AS referencing_object_fullname,
                  referenced_type_desc
         FROM    ##path_list
         WHERE   path_list_id = @v_path_list_id - 1
         )
         INSERT INTO ##path_list (path_list_id, path, referencing_object_fullname, referenced_object_fullname, referenced_type_desc)
         SELECT  @v_path_list_id,
                 CONCAT(b.referencing_object_fullname,',',a.path),
                 b.referencing_object_fullname,
                 a.referencing_object_fullname,
                 b.referenced_type_desc
         FROM    cte_determine_referencing_object a
         INNER JOIN ##path b ON a.referencing_object_fullname = b.referenced_object_fullname
                 AND b.referencing_object_fullname IS NOT NULL
                 AND CHARINDEX(b.referencing_object_fullname, a.path) = 0;

         SET @v_row_count = @@ROWCOUNT;
         PRINT('@v_row_count: ' + CAST(@v_row_count AS VARCHAR(1000)));

         SET @v_path_list_id = @v_path_list_id + 1;

    END;

    INSERT INTO ##path_list_final (path, referenced_object_fullname, referenced_type_desc)
    SELECT  path,
            referenced_object_fullname,
            referenced_type_desc
    FROM    ##path_list r1
    WHERE   1=1 AND
            NOT EXISTS (
                SELECT 1 FROM ##path_list r2
                WHERE r2.path LIKE r1.path + ',%'
            );

    SELECT  DISTINCT 
            id,
            REPLACE(path,',',N'   ‚¨ÖÔ∏è   ') AS [path], 
            SUBSTRING(path, 1, CHARINDEX(',', [path]) - 1) AS referencing_object_fullname,
            (LEN(path) - LEN(REPLACE(path, ',', ''))) AS depth            
    FROM    ##path_list_final

END
GO
```
