<img src="https://raw.githubusercontent.com/smpetersgithub/AdvancedSQLPuzzles/main/images/AdvancedSQLPuzzles_image.png" alt="Advanced SQL Puzzles" width="200"/>

# Foreign Key Dependency Path Analysis Script


Next, we‚Äôll focus on determining foreign key paths. This is similar to determining object dependency paths, but here we focus exclusively on foreign key dependencies. A script provided at the end of this chapter automates this process.

Foreign key dependencies can be viewed via the system views `sys.foregn_keys` and `sys.foreign_key_columns` system views.  Foreign Key dependencies are not part of the `sys.sql_Expression_dependencies` table.

Foreign keys cannot be created across databases, so unlike object dependency paths, we do not need to account for cross-database foreign keys.  Before you run the script, you will need to modify the `USE` statement to use the correct database.

Before running the script, we will cover a few key concepts.

[üìÑ The corresponding scripts for this walkthrough are available here.](https://github.com/smpetersgithub/AdvancedSQLPuzzles/tree/main/Database%20Articles/Database%20Dependencies/)

----

### Example Output

First, we‚Äôll review the example output generated by the script.

These examples are based on Microsoft‚Äôs publicly available `WorldWideImporters` database.

The following illustrates a foreign key path for the `Orders` table. From this output, we can identify all objects that the table depends on via foreign keys, as well as the dependencies of those related tables.

üîç Objects are labeled using a three-part naming convention: `<server_name>.<schema>.<object_name>`

----

| ID | Table Name                      | Path                                                                     | Depth |
|----|---------------------------------|--------------------------------------------------------------------------|-------|
| 1  | Sales.Orders                    | Sales.Orders                                                             | 0     |
| 2  | Application.People              | Sales.Orders  ‚û°Ô∏è  Application.People                                    | 1     |
| 3  | Application.Cities              | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Application.Cities              | 2     |
| 4  | Application.Countries           | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Application.Countries           | 2     |
| 5  | Application.DeliveryMethods     | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Application.DeliveryMethods     | 2     |
| 6  | Application.PaymentMethods      | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Application.PaymentMethods      | 2     |
| 7  | Application.StateProvinces      | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Application.StateProvinces      | 2     |
| 8  | Application.SystemParameters    | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Application.SystemParameters    | 2     |
| 9  | Application.TransactionTypes    | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Application.TransactionTypes    | 2     |
| 10 | Purchasing.PurchaseOrderLines   | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Purchasing.PurchaseOrderLines   | 2     |
| 11 | Purchasing.PurchaseOrders       | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Purchasing.PurchaseOrders       | 2     |
| 12 | Purchasing.SupplierCategories   | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Purchasing.SupplierCategories   | 2     |
| 13 | Purchasing.Suppliers            | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Purchasing.Suppliers            | 2     |
| 14 | Purchasing.SupplierTransactions | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Purchasing.SupplierTransactions | 2     |
| 15 | Sales.BuyingGroups              | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Sales.BuyingGroups              | 2     |
| 16 | Sales.CustomerCategories        | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Sales.CustomerCategories        | 2     |
| 17 | Sales.CustomerTransactions      | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Sales.CustomerTransactions      | 2     |
| 18 | Sales.InvoiceLines              | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Sales.InvoiceLines              | 2     |
| 19 | Sales.SpecialDeals              | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Sales.SpecialDeals              | 2     |
| 20 | Warehouse.Colors                | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Warehouse.Colors                | 2     |
| 21 | Warehouse.PackageTypes          | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Warehouse.PackageTypes          | 2     |
| 22 | Warehouse.StockGroups           | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Warehouse.StockGroups           | 2     |
| 23 | Warehouse.StockItemHoldings     | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Warehouse.StockItemHoldings     | 2     |
| 24 | Warehouse.StockItems            | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Warehouse.StockItems            | 2     |
| 25 | Warehouse.StockItemStockGroups  | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Warehouse.StockItemStockGroups  | 2     |
| 26 | Warehouse.StockItemTransactions | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Warehouse.StockItemTransactions | 2     |
| 27 | Sales.Customers                 | Sales.Orders  ‚û°Ô∏è  Sales.Customers                                       | 1     |
| 28 | Sales.Invoices                  | Sales.Orders ‚û°Ô∏è Sales.Invoices                                          | 1     |
| 29 | Sales.OrderLines                | Sales.Orders ‚û°Ô∏è Sales.OrderLines                                        | 1     |

----

We can also determine reverse dependencies.  In this example, we identify all objects that have a foreign key path to the `Orders` table.

| ID | TableName                       | Path                                                               | Depth |
|----|---------------------------------|--------------------------------------------------------------------|-------|
| 1  | Sales.Orders                    | Sales.Orders                                                       | 0     |
| 2  | Sales.Invoices                  | Sales.Invoices ‚¨ÖÔ∏è Sales.Orders                                     | 1    |
| 3  | Sales.OrderLines                | Sales.OrderLines ‚¨ÖÔ∏è Sales.Orders                                   | 1    |
| 4  | Sales.CustomerTransactions      | Sales.CustomerTransactions ‚¨ÖÔ∏è Sales.Invoices ‚¨ÖÔ∏è Sales.Orders      | 2     |
| 5  | Sales.InvoiceLines              | Sales.InvoiceLines ‚¨ÖÔ∏è Sales.Invoices ‚¨ÖÔ∏è Sales.Orders              | 2     |
| 6  | Warehouse.StockItemTransactions | Warehouse.StockItemTransactions ‚¨ÖÔ∏è Sales.Invoices ‚¨ÖÔ∏è Sales.Orders | 2     |

----

### Temporary Stored Procedures Created

The script creates the following global temporary stored procedures. I‚Äôve modularized the logic to improve readability and maintainability.

While I won‚Äôt go into the implementation details here, you can paste the code into a large language model (LLM) to get a high-level summary of each procedure‚Äôs functionality.

```text
##temp_create_tables
##temp_sp_determine_fk_paths;
##temp_sp_determine_fk_paths_reverse;
```
---

### Usage Notes

To execute the temporary stored procedures, first run the script to create them, and then execute the procedures.

For this example, we are using the `WideWorldImports` database on the `Orders` table.  You‚Äôll need to update the script‚Äôs USE statement to point to the correct database.

The `##Table_Foreign_Keys_Map` table is available if you need details about the columns involved in each foreign key relationship.

#### Example Execution

```sql
EXECUTE ##temp_create_tables;
EXECUTE ##temp_sp_determine_fk_paths 'Orders';
EXECUTE ##temp_sp_determine_fk_paths_reverse 'Orders';


--View the FK mappings
SELECT * FROM ##Table_Foreign_Keys_Map;
```

#### Selecting a Dependency Path Procedure

Use one of the following stored procedures based on the direction of analysis. You‚Äôll need to pass the target object as a parameter:

* `##temp_sp_determine_fk_paths` ‚Äì Traces downstream foreign key dependencies (what the object depends on)
* `##temp_sp_determine_fk_paths_reverse` ‚Äì Traces upstream foreign key dependencies (what depends on the object)

---

#### Current Limitations

These limitations are planned to be addressed in future versions of the script:

1. Single Table Dependency Resolution

    *  The script currently resolves foreign key dependencies for one table at a time. It does not generate dependency chains for all tables in a database. This design is intentional, as processing the full dependency map for an entire database can be computationally intensive.

2. Ambiguous Object Names Across Schemas

    *  If the specified table exists in multiple schemas, each instance is included in the output. You will need to manually identify and filter the correct table as needed.

---

### SQL Script

And now, without further ado, here is the script to generate foreign key dependency paths.  This script is also located in the GitHub repository.

```sql
USE WideWorldImporters;
GO

/*

üìã Instructions

https://github.com/smpetersgithub/AdvancedSQLPuzzles/tree/main/Database%20Articles/Database%20Dependencies

1. Update the USE statement for the correct database
2. Create the temporary stored procedures
3. Execute the stored procedures

--------------------------------------------------------
--------------------------------------------------------

Please use the following to execute the stored procedures.

EXECUTE ##temp_create_tables;
EXECUTE ##temp_sp_determine_fk_paths 'Orders';
EXECUTE ##temp_sp_determine_fk_paths_reverse 'Orders';


--View the FK mappings
SELECT * FROM ##Table_Foreign_Keys_Map;
*/

USE WideWorldImporters;
GO

/*
üìã Instructions

Please vist the following URL for instructions.

1. Update the USE statement for the correct database
1. Create the temporary stored procedures
2. Set the variables
3. Execute the stored procedures in the same session.

--------------------------------------------------------
--------------------------------------------------------

Please use the following to execute the stored procedures.

EXECUTE ##temp_create_tables;
EXECUTE ##temp_sp_determine_fk_paths 'Orders';
EXECUTE ##temp_sp_determine_fk_paths_reverse 'Orders';


--View the FK mappings
SELECT * FROM ##Table_Foreign_Keys_Map;

*/

CREATE OR ALTER PROCEDURE ##temp_create_tables 
AS
BEGIN
    DROP TABLE IF EXISTS ##Paths;
    CREATE TABLE ##Paths
    (
        TableID   INTEGER,
        TableName SYSNAME,
        [Path]   NVARCHAR(MAX),
        Depth     INT,
        Processed BIT DEFAULT 0
    );
    
    DROP TABLE IF EXISTS ##Table_Foreign_Keys_Map;
    SELECT  
        fk.[name] AS ForeignKeyName,
        tp.[object_id] AS ParentTableID,
        s_tp.[name] AS ParentSchema,
        CONCAT_WS('.', s_tp.[name], tp.[name]) AS ParentTable,
        cp.[name] AS ParentColumn,
        refp.[object_id] AS ReferencedTableID,
        s_ref.[name] AS ReferencedSchema,
        CONCAT_WS('.', s_ref.[name], refp.[name]) AS ReferencedTable,
        cref.[name] AS ReferencedColumn
    INTO ##Table_Foreign_Keys_Map
    FROM sys.foreign_keys fk
    INNER JOIN sys.foreign_key_columns fkc 
        ON fkc.constraint_object_id = fk.[object_id]
    INNER JOIN sys.tables tp 
        ON fkc.parent_object_id = tp.[object_id]
    INNER JOIN sys.schemas s_tp 
        ON tp.schema_id = s_tp.schema_id
    INNER JOIN sys.columns cp 
        ON fkc.parent_object_id = cp.[object_id] 
       AND fkc.parent_column_id = cp.column_id
    INNER JOIN sys.tables refp 
        ON fkc.referenced_object_id = refp.[object_id]
    INNER JOIN sys.schemas s_ref 
        ON refp.schema_id = s_ref.schema_id
    INNER JOIN sys.columns cref 
        ON fkc.referenced_object_id = cref.[object_id] 
       AND fkc.referenced_column_id = cref.column_id;
END;
GO

---------------------------------------------------------------------------
---------------------------------------------------------------------------
---------------------------------------------------------------------------
---------------------------------------------------------------------------
CREATE OR ALTER PROCEDURE ##temp_sp_determine_fk_paths (@v_object_name VARCHAR(1000)) AS
BEGIN
    DECLARE @MaxIterations INT = 100;
    DECLARE @Iteration INT = 0;

    -- Seed with starting table
    INSERT INTO ##Paths (TableID, TableName, [Path], Depth, Processed)
    SELECT 
        t.object_id, 
        s.[name] + '.' + t.[name],
        s.[name] + '.' + t.[name],
        0, 
        0
    FROM sys.tables t
    INNER JOIN sys.schemas s ON t.schema_id = s.schema_id
    WHERE t.[name] = @v_object_name;

    -- Loop until no more unprocessed or max iteration
    WHILE EXISTS (SELECT 1 FROM ##Paths WHERE Processed = 0) AND @Iteration < @MaxIterations
    BEGIN
        SET @Iteration += 1;

        DECLARE @CurrentTableID INT, @CurrentPath NVARCHAR(MAX), @CurrentDepth INT;
        SELECT TOP (1)
            @CurrentTableID = TableID,
            @CurrentPath = [Path],
            @CurrentDepth = Depth
        FROM ##Paths
        WHERE Processed = 0
        ORDER BY Depth;

        -- From parent -> child (referenced table)
        INSERT INTO ##Paths (TableID, TableName, [Path], Depth, Processed)
        SELECT fk.ReferencedTableID, fk.ReferencedTable,
               @CurrentPath + N'  ‚û°Ô∏è  ' + fk.ReferencedTable,
               @CurrentDepth + 1, 0
        FROM ##Table_Foreign_Keys_Map fk
        WHERE fk.ParentTableID = @CurrentTableID
          AND NOT EXISTS (
              SELECT 1 FROM ##Paths 
              WHERE TableID = fk.ReferencedTableID 
              AND [Path] COLLATE DATABASE_DEFAULT LIKE '%' + fk.ReferencedTable COLLATE DATABASE_DEFAULT + '%'
          );

        -- From child -> parent (parent table)
        INSERT INTO ##Paths (TableID, TableName, [Path], Depth, Processed)
        SELECT fk.ParentTableID, fk.ParentTable,
               @CurrentPath + N' ‚û°Ô∏è ' + fk.ParentTable,
               @CurrentDepth + 1, 0
        FROM ##Table_Foreign_Keys_Map fk
        WHERE fk.ReferencedTableID = @CurrentTableID
          AND NOT EXISTS (
              SELECT 1 FROM ##Paths 
              WHERE TableID = fk.ParentTableID 
              AND [Path] COLLATE DATABASE_DEFAULT LIKE '%' + fk.ParentTable COLLATE DATABASE_DEFAULT + '%'
          );

        -- Mark processed
        UPDATE ##Paths
        SET Processed = 1
        WHERE TableID = @CurrentTableID AND [Path] = @CurrentPath;
    END;

    -- Final results
    SELECT DISTINCT @@SERVERNAME AS ServerName, TableName, [Path], Depth
    FROM ##Paths
    ORDER BY Path, Depth;
END;
GO


---------------------------------------------------------------------------
---------------------------------------------------------------------------
---------------------------------------------------------------------------
---------------------------------------------------------------------------
CREATE OR ALTER PROCEDURE ##temp_sp_determine_fk_paths_reverse (@v_object_name SYSNAME) AS
BEGIN
    DECLARE @MaxIterations INT = 100;
    DECLARE @Iteration INT = 0;

    IF OBJECT_ID('tempdb..##Paths') IS NOT NULL
        DELETE FROM ##Paths;

    -- Seed with starting table
    INSERT INTO ##Paths (TableID, TableName, [Path], Depth, Processed)
    SELECT 
        t.object_id, 
        s.[name] + '.' + t.[name],
        s.[name] + '.' + t.[name],
        0, 
        0
    FROM sys.tables t
    INNER JOIN sys.schemas s ON t.schema_id = s.schema_id
    WHERE t.[name] = @v_object_name;

    -- Loop until no more unprocessed or max iteration
    WHILE EXISTS (SELECT 1 FROM ##Paths WHERE Processed = 0) AND @Iteration < @MaxIterations
    BEGIN
        SET @Iteration += 1;

        DECLARE @CurrentTableID INT, @CurrentPath NVARCHAR(MAX), @CurrentDepth INT;
        SELECT TOP (1)
            @CurrentTableID = TableID,
            @CurrentPath = [Path],
            @CurrentDepth = Depth
        FROM ##Paths
        WHERE Processed = 0
        ORDER BY Depth;

        -- From child ‚Üí parent
        INSERT INTO ##Paths (TableID, TableName, [Path], Depth, Processed)
        SELECT fk.ParentTableID, fk.ParentTable,
               fk.ParentTable + N' ‚¨ÖÔ∏è ' + @CurrentPath,
               @CurrentDepth + 1, 0
        FROM ##Table_Foreign_Keys_Map fk
        WHERE fk.ReferencedTableID = @CurrentTableID
          AND NOT EXISTS (
              SELECT 1 FROM ##Paths 
              WHERE TableID = fk.ParentTableID 
              AND [Path] COLLATE DATABASE_DEFAULT LIKE '%' + fk.ParentTable COLLATE DATABASE_DEFAULT + '%'
          );

        -- Mark as processed
        UPDATE ##Paths
        SET Processed = 1
        WHERE TableID = @CurrentTableID AND [Path] = @CurrentPath;
    END;

    -- Final results
    SELECT DISTINCT @@SERVERNAME AS ServerName, TableName, [Path], Depth
    FROM ##Paths
    ORDER BY Depth, [Path];
END;
GO
```
```
END;
GO
