<img src="https://raw.githubusercontent.com/smpetersgithub/AdvancedSQLPuzzles/main/images/AdvancedSQLPuzzles_image.png" alt="Advanced SQL Puzzles" width="200"/>

# Object Dependency Path Analysis Script


Next, we‚Äôll focus on determining foreign key paths. This is similar to determining object dependency paths, but here we focus exclusively on foreign key dependencies. A script provided at the end of this chapter automates this process.

Foreign key dependencies can be viewed via the system views `sys.foregn_keys` and `sys.foreign_key_columns` system views.  Foreign Key dependencies are not part of the `sys.sql_Expression_dependencies` table.

Foreign keys cannot be created across databases, so unlike object dependency paths, we do not need to account for cross-database foreign keys.  Before you run the script, you will need to modify the `USE` statement to use the correct databse.

Before running the script, we will cover a few key concepts.

[üëç The corresponding scripts for this walkthrough are available here.](https://github.com/smpetersgithub/AdvancedSQLPuzzles/tree/main/Database%20Articles/Database%20Dependencies/)

----

### Example Output

First, we‚Äôll review the example output generated by the script.

These examples are based on Microsoft‚Äôs publicly available WorldWideImporters database.

The following illustrates a foreign key path for the Orders table. From this output, we can identify all objects that the table depends on via foreign keys, as well as the dependencies of those related tables.

üîç Objects are labeled using a four-part naming convention `<server_name>.<schema>.<object_name>.<object_type>`

----

| ID | Table Name                      | Path                                                                     | Depth |
|----|---------------------------------|--------------------------------------------------------------------------|-------|
| 1  | Sales.Orders                    | Sales.Orders                                                             | 0     |
| 2  | Application.People              | Sales.Orders  ‚û°Ô∏è  Application.People                                    | 1     |
| 3  | Application.Cities              | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Application.Cities              | 2     |
| 4  | Application.Countries           | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Application.Countries           | 2     |
| 5  | Application.DeliveryMethods     | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Application.DeliveryMethods     | 2     |
| 6  | Application.PaymentMethods      | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Application.PaymentMethods      | 2     |
| 7  | Application.StateProvinces      | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Application.StateProvinces      | 2     |
| 8  | Application.SystemParameters    | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Application.SystemParameters    | 2     |
| 9  | Application.TransactionTypes    | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Application.TransactionTypes    | 2     |
| 10 | Purchasing.PurchaseOrderLines   | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Purchasing.PurchaseOrderLines   | 2     |
| 11 | Purchasing.PurchaseOrders       | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Purchasing.PurchaseOrders       | 2     |
| 12 | Purchasing.SupplierCategories   | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Purchasing.SupplierCategories   | 2     |
| 13 | Purchasing.Suppliers            | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Purchasing.Suppliers            | 2     |
| 14 | Purchasing.SupplierTransactions | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Purchasing.SupplierTransactions | 2     |
| 15 | Sales.BuyingGroups              | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Sales.BuyingGroups              | 2     |
| 16 | Sales.CustomerCategories        | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Sales.CustomerCategories        | 2     |
| 17 | Sales.CustomerTransactions      | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Sales.CustomerTransactions      | 2     |
| 18 | Sales.InvoiceLines              | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Sales.InvoiceLines              | 2     |
| 19 | Sales.SpecialDeals              | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Sales.SpecialDeals              | 2     |
| 20 | Warehouse.Colors                | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Warehouse.Colors                | 2     |
| 21 | Warehouse.PackageTypes          | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Warehouse.PackageTypes          | 2     |
| 22 | Warehouse.StockGroups           | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Warehouse.StockGroups           | 2     |
| 23 | Warehouse.StockItemHoldings     | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Warehouse.StockItemHoldings     | 2     |
| 24 | Warehouse.StockItems            | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Warehouse.StockItems            | 2     |
| 25 | Warehouse.StockItemStockGroups  | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Warehouse.StockItemStockGroups  | 2     |
| 26 | Warehouse.StockItemTransactions | Sales.Orders  ‚û°Ô∏è  Application.People ‚û°Ô∏è Warehouse.StockItemTransactions | 2     |
| 27 | Sales.Customers                 | Sales.Orders  ‚û°Ô∏è  Sales.Customers                                       | 1     |
| 28 | Sales.Invoices                  | Sales.Orders ‚û°Ô∏è Sales.Invoices                                          | 1     |
| 29 | Sales.OrderLines                | Sales.Orders ‚û°Ô∏è Sales.OrderLines                                        | 1     |

----

We can also determine reverse dependencies.  In this example, we identify all objects that have a foreign key path to the `Orders` table.

| ID | TableName                       | Path                                                               | Depth |
|----|---------------------------------|--------------------------------------------------------------------|-------|
| 1  | Sales.Orders                    | Sales.Orders                                                       | 0     |
| 2  | Sales.Invoices                  | Sales.Invoices ‚¨ÖÔ∏è Sales.Orders                                     | 1    |
| 3  | Sales.OrderLines                | Sales.OrderLines ‚¨ÖÔ∏è Sales.Orders                                   | 1    |
| 4  | Sales.CustomerTransactions      | Sales.CustomerTransactions ‚¨ÖÔ∏è Sales.Invoices ‚¨ÖÔ∏è Sales.Orders      | 2     |
| 5  | Sales.InvoiceLines              | Sales.InvoiceLines ‚¨ÖÔ∏è Sales.Invoices ‚¨ÖÔ∏è Sales.Orders              | 2     |
| 6  | Warehouse.StockItemTransactions | Warehouse.StockItemTransactions ‚¨ÖÔ∏è Sales.Invoices ‚¨ÖÔ∏è Sales.Orders | 2     |

----

### Temporary Stored Procedures Created

The script creates the following global temporary stored procedures. I‚Äôve modularized the logic to improve readability and maintainability.

While I won‚Äôt go into the implementation details here, you can paste the code into a large language model (LLM) to get a high-level summary of each procedure‚Äôs functionality.

```text
##temp_create_tables
##temp_sp_determine_fk_paths;
##temp_sp_determine_fk_paths_reverse;
```
---

### Usage Notes

To execute the temporary stored procedures, first run the script to create them, and then execute the procedures.

For this example, we are using the `WideWorldImports` database on the `Orders` table.  You‚Äôll need to update the script‚Äôs USE statement to point to the correct database.

The `##Table_Foreign_Keys_Map` table is available if you need details about the columns involved in each foreign key relationship.

#### Example Execution

```sql
EXECUTE ##temp_create_tables;
EXECUTE ##temp_sp_determine_fk_paths 'Orders';
EXECUTE ##temp_sp_determine_fk_paths_reverse 'Orders';


--View the FK mappings
SELECT * FROM ##Table_Foreign_Keys_Map;
```

#### Selecting a Dependency Path Procedure

Use one of the following stored procedures based on the direction of analysis. You‚Äôll need to pass the target object as a parameter:

* `##temp_sp_determine_fk_paths` ‚Äì Traces downstream foreign key dependencies (what the object depends on)
* `##temp_sp_determine_fk_paths_reverse` ‚Äì Traces upstream foreign key dependencies (what depends on the object)

---

#### Current Limitations

These limitations are planned to be addressed in future versions of the script:

1. Single Table Dependency Resolution

    *  The script currently resolves foreign key dependencies for one table at a time. It does not generate dependency chains for all tables in a database. This design is intentional, as processing the full dependency map for an entire database can be computationally intensive.

2. Ambiguous Object Names Across Schemas

    *  If the specified table exists in multiple schemas, each instance is included in the output. You will need to manually identify and filter the correct table as needed.

---

### SQL Script

And now, without further ado, here is the script to generate database dependency paths.  This script is also located in the GitHub repository.

```sql
/*
üìã Instructions

https://github.com/smpetersgithub/AdvancedSQLPuzzles/tree/main/Database%20Articles/Database%20Dependencies

1. Create the temporary stored procedures
2. Set the variables
3. Execute the stored procedures in the same session.

--------------------------------------------------------
--------------------------------------------------------

Please use the following to execute the stored procedures.

-------
--DECLARE @v_database VARCHAR(100) = '''WideWorldImporters'',''AdventureWorksDW''';  --Multiple databases example declaration
DECLARE @v_database VARCHAR(100) = '''WideWorldImporters''';
PRINT('Ensure the stings has single quotes around each value: ' + @v_database)
-------

EXECUTE ##temp_sp_create_tables @v_database;
EXECUTE ##temp_sp_insert_sql_statement;
EXECUTE ##temp_sp_cursor_insert_sql_expression_dependencies;
EXECUTE ##temp_sp_cursor_insert_sys_objects;
EXECUTE ##temp_sp_update_sql_expression_dependencies;

-------
DECLARE @v_object_name VARCHAR(100) = 'SearchForPeople';
EXECUTE ##temp_sp_determine_paths @v_object_name;
-------
DECLARE @v_object_name_reverse_path VARCHAR(100) = 'Customers';
EXECUTE ##temp_sp_determine_reverse_paths @v_object_name_reverse_path;
-------

*/

USE [master];
GO

SET NOCOUNT ON; SET ANSI_WARNINGS OFF;
GO

CREATE OR ALTER PROCEDURE ##temp_sp_create_tables (@vdatabaselist VARCHAR(1000)) AS
BEGIN

    -- Drop temporary tables if they exist
    DROP TABLE IF EXISTS ##databases;
    DROP TABLE IF EXISTS ##sql_statement;
    DROP TABLE IF EXISTS ##sql_expression_dependencies;
    DROP TABLE IF EXISTS ##self_referencing_objects;
    DROP TABLE IF EXISTS ##sys_objects;
    DROP TABLE IF EXISTS ##path;
    DROP TABLE IF EXISTS ##path_list;
    DROP TABLE IF EXISTS ##path_list_final;

    CREATE TABLE ##databases (
        database_id INT PRIMARY KEY,
        [database_name] VARCHAR(128)
    );

    --SELECT * FROM ##databases;

    DECLARE @v_sql_statement NVARCHAR(MAX);
    SET @v_sql_statement = REPLACE('INSERT INTO ##databases (database_id, [database_name]) SELECT database_id, [name] FROM sys.databases WHERE NAME IN (<DATABASE_STRING>);','<DATABASE_STRING>', @vDatabaseList);
    PRINT(@v_sql_statement);
    EXEC sp_executesql @v_sql_statement;


    -----------------------------------------------------------------------
    -- Create a table to store dependencies across databases
    CREATE TABLE ##sql_expression_dependencies 
    (
        sql_expression_dependencies_id INT IDENTITY(1,1) PRIMARY KEY,
        referencing_id                 INT NOT NULL,
        referencing_database_name      VARCHAR(128),
        referencing_schema_name        VARCHAR(128),
        referencing_object_name        VARCHAR(128),
        referencing_type_desc          VARCHAR(128),
        referenced_id                  INT,
        referenced_database_name       VARCHAR(128),
        referenced_schema_name         VARCHAR(128),
        referenced_object_name         VARCHAR(128),
        referenced_type_desc           VARCHAR(128),
        depth                          INT,
        referencing_object_fullname    VARCHAR(128),
        referenced_object_fullname     VARCHAR(128),
        referencing_minor_id           INT,
        referencing_class_desc         VARCHAR(128),
        is_schema_bound_reference      INT,
        referenced_class               INT,
        referenced_class_desc          VARCHAR(128),
        referenced_server_name         VARCHAR(128),
        referenced_minor_id            INT,
        is_caller_dependent            INT,
        is_ambiguous                   INT

    );

    CREATE TABLE ##self_referencing_objects 
    (
        sql_expression_dependencies_id INT,
        referencing_id                 INT NOT NULL,
        referencing_database_name      VARCHAR(128),
        referencing_schema_name        VARCHAR(128),
        referencing_object_name        VARCHAR(128),
        referencing_type_desc          VARCHAR(128),
        referenced_id                  INT,
        referenced_database_name       VARCHAR(128),
        referenced_schema_name         VARCHAR(128),
        referenced_object_name         VARCHAR(128),
        referenced_type_desc           VARCHAR(128),
        depth                          INT,
        referencing_object_fullname    VARCHAR(100),
        referenced_object_fullname     VARCHAR(100),
        referencing_minor_id           INT,
        referencing_class_desc         VARCHAR(128),
        is_schema_bound_reference      INT,
        referenced_class               INT,
        referenced_class_desc          VARCHAR(128),
        referenced_server_name         VARCHAR(128),
        referenced_minor_id            INT,
        is_caller_dependent            INT,
        is_ambiguous                   INT
    );

    CREATE TABLE ##sys_objects (
        [object_id]     INT NOT NULL,
        [database_name] VARCHAR(128),
        [schema_name]   VARCHAR(128),
        [object_name]   VARCHAR(128),
        [type_desc]     VARCHAR(128),
        CONSTRAINT PK_sys_objects PRIMARY KEY ([object_id], [database_name])
        );
    
    CREATE TABLE ##path (
        path_id                     INT IDENTITY(1,1) PRIMARY KEY,
        referencing_object_name     VARCHAR(128) NULL,
        referencing_object_fullname VARCHAR(128) NULL,
        referenced_object_name      VARCHAR(128) NULL,
        referenced_object_fullname  VARCHAR(128) NULL,
        referenced_type_desc        VARCHAR(128) NULL
    );
    
    CREATE TABLE ##path_list (
        path_list_id                INT NOT NULL,
        path                        VARCHAR(1000) PRIMARY KEY NOT NULL,
        referencing_object_fullname VARCHAR(128) NULL,
        referenced_object_fullname  VARCHAR(128) NULL,
        referenced_type_desc        VARCHAR(128) NULL
    );
    
    DROP TABLE IF EXISTS ##path_list_final;
    CREATE TABLE ##path_list_final (
        id                         INTEGER IDENTITY(1,1) PRIMARY KEY,
        [path]                     VARCHAR(4000) NOT NULL,
        referenced_object_fullname VARCHAR(128) NULL,
        referenced_type_desc       VARCHAR(128) NULL
    );
      
    -- 1. Core dependency lookup index
    CREATE INDEX IX_sql_expression_dependencies_referencing_referenced 
    ON ##sql_expression_dependencies (referencing_object_fullname, referenced_object_fullname) 
    INCLUDE (referencing_id, referenced_id);
    
    -- 2. paths table lookup index  
    CREATE INDEX IX_paths_referencing_referenced
    ON ##path (referencing_object_fullname, referenced_object_fullname)
    INCLUDE (referencing_object_name);
    
    -- 3. pathsList processing index
    CREATE INDEX IX_pathslist_path_list_id_path
    ON ##path_list (path)
    INCLUDE (referencing_object_fullname, referenced_object_fullname, referenced_type_desc);
    
    CREATE NONCLUSTERED INDEX IX_path_list_path_desc
    ON ##path_list (path, referenced_type_desc);

    -- 4. Object lookup index
    CREATE INDEX IX_sys_objects_lookup
    ON ##sys_objects ([database_name], [schema_name], [object_name], [object_id])
    INCLUDE ([type_desc]);
    
    -- 5. Dependency updates index
    CREATE INDEX IX_sql_expression_dependencies_referenced_id
    ON ##sql_expression_dependencies (referenced_id, referencing_database_name);

END;
GO

CREATE OR ALTER PROCEDURE ##temp_sp_insert_sql_statement
AS
BEGIN

    
    SELECT id, rowid, sqlline
    INTO   ##sql_statement
    FROM (VALUES
    -----------------------------------------------
    (1, 10, 'WITH cte_sql_expression_dependencies AS'),
    (1, 20, '('),
    (1, 30, 'SELECT *'),
    (1, 40, 'FROM   vdatabase_name.sys.sql_expression_dependencies'),
    (1, 50, 'WHERE  1=1'), 
    (1, 60, ')'),
    -----------------------------------------------
    (1, 70, 'INSERT INTO ##sql_expression_dependencies ('),
    ----------------
    (1, 80, 'referencing_id,'),
    (1, 90, 'referencing_database_name,'),
    (1, 100, 'referencing_schema_name,'),
    (1, 110, 'referencing_object_name,'),
    (1, 120, 'referencing_type_desc,'),

    (1, 130, 'referenced_database_name,'),
    (1, 140, 'referenced_schema_name,'),
    (1, 150, 'referenced_object_name,'),
    (1, 160, 'referenced_id,'),

    (1, 161, 'referencing_minor_id,'),
    (1, 162, 'referencing_class_desc,'),
    (1, 163, 'is_schema_bound_reference,'),
    (1, 164, 'referenced_class,'),
    (1, 165, 'referenced_class_desc,'),
    (1, 166, 'referenced_server_name,'),
    (1, 167, 'referenced_minor_id,'),
    (1, 168, 'is_caller_dependent,'),
    (1, 169, 'is_ambiguous'),
    (1, 170, ')'),
    -----------------------------------------------
    (1, 180, 'SELECT'),
    (1, 190, 'd.referencing_id,'),
    (1, 200, 'DB_NAME(vdatabase_id) AS referencing_database_name,'),
    (1, 210, 's.[name] AS referencing_schema_name,'),    
    (1, 220, 'o.name AS referencing_object_name,'),
    (1, 230, 'o.type_desc AS referencing_type_desc,'),
    (1, 240, 'd.referenced_database_name,'),
    (1, 250, 'd.referenced_schema_name,'),
    (1, 260, 'd.referenced_entity_name,'),
    (1, 270, 'd.referenced_id,'),
    (1, 271, 'referencing_minor_id,'),
    (1, 272, 'referencing_class_desc,'),
    (1, 273, 'is_schema_bound_reference,'),
    (1, 274, 'referenced_class,'),
    (1, 275, 'referenced_class_desc,'),
    (1, 276, 'referenced_server_name,'),
    (1, 277, 'referenced_minor_id,'),
    (1, 278, 'is_caller_dependent,'),
    (1, 279, 'is_ambiguous'),
    -----------------------------------------------
    (1, 280, 'FROM'),
    (1, 290, 'cte_sql_expression_dependencies d'),
    (1, 300, 'INNER JOIN vdatabase_name.sys.objects o ON d.referencing_id = o.object_id'),
    (1, 310, 'INNER JOIN vdatabase_name.sys.schemas s ON o.schema_id = s.schema_id;'),
    -----------------------------------------------
    (2, 10, 'INSERT INTO ##sys_objects (object_id, database_name, schema_name, object_name, type_desc)'),
    (2, 20,  'SELECT'),
    (2, 25,  'o.object_id,'),
    (2, 30,  '''vdatabase_name'','),
    (2, 40,  's.name AS schema_name,'),
    (2, 50,  'o.name AS object_name,'),
    (2, 60,  'type_desc'),
    (2, 70,  'FROM vdatabase_name.sys.objects o INNER JOIN'),
    (2, 80,  'vdatabase_name.sys.schemas s ON o.schema_id = s.schema_id'),
    (2, 90,  'WHERE is_ms_shipped = 0;')
    ) AS a(id, RowID, SQLLine);

/***********************************************************************************
SELECT  REPLACE(REPLACE(sqlline, 'vdatabase_name', 'QA07_Greg'),'vdatabase_id','') 
FROM    ##sql_statement
WHERE   id = 1
***********************************************************************************/
END;
GO

CREATE OR ALTER PROCEDURE ##temp_sp_cursor_insert_sql_expression_dependencies AS
BEGIN
    -- Declare variables
    DECLARE @v_database_id INT;
    DECLARE @v_database_name NVARCHAR(128);
    DECLARE @v_sql_statement NVARCHAR(MAX);

    -- Declare the cursor
    DECLARE mycursor CURSOR FOR SELECT database_id, [database_name] FROM ##databases;

    -- Open the cursor
    OPEN mycursor;

    -- Fetch the first row
    FETCH NEXT FROM mycursor INTO @v_database_id, @v_database_name;

    -- Loop through the cursor
    WHILE @@FETCH_STATUS = 0
    BEGIN

        -- Construct dynamic SQL statement for dependency analysis
        SELECT @v_sql_statement = STRING_AGG(sqlline, ' ')
        FROM   ##sql_statement
        WHERE  ID = 1;
        
        -- Replace placeholders in the SQL statement
        SET @v_sql_statement = REPLACE(@v_sql_statement, 'vdatabase_name', @v_database_name);
        SET @v_sql_statement = REPLACE(@v_sql_statement, 'vdatabase_id', CAST(@v_database_id AS NVARCHAR));
        
        -- Execute the dynamic SQL
        EXEC sp_executesql @v_sql_statement;

        -- Fetch the next row
        FETCH NEXT FROM mycursor INTO @v_database_id, @v_database_name;
    END;

    -- Close and deallocate the cursor
    CLOSE mycursor;
    DEALLOCATE mycursor;

END;
GO

CREATE OR ALTER PROCEDURE ##temp_sp_cursor_insert_sys_objects AS
BEGIN
    -- Declare variables
    DECLARE @v_database_id INT;
    DECLARE @v_database_name NVARCHAR(128);
    DECLARE @v_sql_statement NVARCHAR(MAX);

    -- Declare the cursor
    DECLARE mycursor CURSOR FOR 
    SELECT database_id, [database_name]
    FROM   ##databases;

    -- Open the cursor
    OPEN mycursor;

    -- Fetch the first row
    FETCH NEXT FROM mycursor INTO @v_database_id, @v_database_name;

    -- Loop through the cursor
    WHILE @@FETCH_STATUS = 0
    BEGIN

        -- Construct dynamic SQL statement for dependency analysis
        SELECT @v_sql_statement = STRING_AGG(sqlline, ' ') 
        FROM   ##sql_statement 
        WHERE  ID = 2;

        -- Replace placeholders in the SQL statement
        SET @v_sql_statement = REPLACE(@v_sql_statement, 'vdatabase_name', @v_database_name);
        SET @v_sql_statement = REPLACE(@v_sql_statement, 'vdatabase_id', CAST(@v_database_id AS NVARCHAR));

        -- Execute the dynamic SQL
        EXEC sp_executesql @v_sql_statement;

        -- Fetch the next row
        FETCH NEXT FROM mycursor INTO @v_database_id, @v_database_name;
    END;

    -- Close and deallocate the cursor
    CLOSE mycursor;
    DEALLOCATE mycursor;
END;
GO

CREATE OR ALTER PROCEDURE ##temp_sp_update_sql_expression_dependencies AS
BEGIN

SET NOCOUNT ON;


-- determine object_types for cross-database dependencies
UPDATE ##sql_expression_dependencies
SET    referenced_id = o.[object_id],
       referenced_type_desc = o.[type_desc]
FROM   ##sql_expression_dependencies db INNER JOIN
       ##sys_objects o ON
           CONCAT('.',db.referenced_database_name, db.referenced_schema_name, db.referenced_object_name)
           =
           CONCAT('.',o.[database_name], o.[schema_name], o.[object_name])
WHERE  db.referenced_database_name IS NOT NULL AND
       db.referenced_schema_name IS NOT NULL;
PRINT('Update Statement - Count of cross-database dependencies: ' + CAST(@@ROWCOUNT AS VARCHAR(1000)));

-- determine object_types for referenced_objects
UPDATE ##sql_expression_dependencies
SET    referenced_id = o.[object_id],
       referenced_type_desc = o.[type_desc],
       referenced_database_name = o.[database_name],
       referenced_schema_name = o.[schema_name]
FROM   ##sql_expression_dependencies db INNER JOIN
       ##sys_objects o ON db.referenced_id = o.[object_id] AND db.referencing_database_name = o.[database_name];
PRINT('Update Statement - Count of object_types for referenced_objects: ' + CAST(@@ROWCOUNT AS VARCHAR(1000)));

-- remove self-referencing objects
-- Most of these will be indexes
DELETE ##sql_expression_dependencies
OUTPUT DELETED.* INTO ##self_referencing_objects
WHERE  referenced_id = referencing_id;
PRINT('Delete Statement - Count of self-referencing objects: ' + CAST(@@ROWCOUNT AS VARCHAR(1000)));

INSERT INTO ##sql_expression_dependencies
(
referencing_id,
referencing_type_desc,
referencing_database_name,
referencing_schema_name,
referencing_object_name,
depth
)
SELECT [object_id],
       [type_desc],
       [database_name],
       [schema_name],
       [object_name],
       1 AS depth
FROM   ##sys_objects
WHERE  [object_id] NOT IN (SELECT referencing_id FROM ##sql_expression_dependencies);


UPDATE ##sql_expression_dependencies
SET    referenced_object_fullname = CONCAT_WS('.',referenced_database_name, referenced_schema_name, referenced_object_name, ISNULL(referenced_type_desc,'UNKNOWN')),
       referencing_object_fullname = CONCAT_WS('.',referencing_database_name, referencing_schema_name, referencing_object_name, ISNULL(referencing_type_desc,'UNKNOWN'));
PRINT('Update Statement - Update referenced_object_fullname and referencing_object_fullname columns: ' + CAST(@@ROWCOUNT AS VARCHAR(1000)));


END;
GO

CREATE OR ALTER PROCEDURE ##temp_sp_determine_paths (@v_object_name VARCHAR(1000)) AS
BEGIN

    TRUNCATE TABLE ##path;
    TRUNCATE TABLE ##path_list;
    TRUNCATE TABLE ##path_list_final;

    INSERT INTO ##path (referencing_object_name, referencing_object_fullname, referenced_object_name, referenced_object_fullname, referenced_type_desc)
    SELECT DISTINCT
           referencing_object_name,
           referencing_object_fullname,
           referenced_object_name,
           (CASE referenced_object_fullname WHEN 'UNKNOWN' THEN NULL ELSE referenced_object_fullname END) AS referenced_object_fullname,
           referenced_type_desc
    FROM   ##sql_expression_dependencies;

    INSERT INTO ##path_list (path_list_id, path, referencing_object_fullname, referenced_object_fullname, referenced_type_desc)
    SELECT  1 AS path_list_id,
            CONCAT(referencing_object_fullname,',',referenced_object_fullname) AS path,
            referencing_object_fullname,
            referenced_object_fullname,
            referenced_type_desc
    FROM    ##path
    WHERE   1=1 
            AND referencing_object_name = @v_object_name
            AND referenced_object_fullname IS NOT NULL;
    
    DECLARE @v_row_count INTEGER = 1;
    DECLARE @v_path_list_id INTEGER = 2;
    
    WHILE @v_row_count >= 1
    BEGIN
         WITH cte_determine_referenced_object AS
         (
         SELECT   path,
                  REVERSE(SUBSTRING(REVERSE(path),0,CHARINDEX(',',REVERSE(path)))) AS referenced_object_fullname,
                  referenced_type_desc
         FROM    ##path_list
         WHERE   path_list_id = @v_path_list_id - 1
         )
         INSERT INTO ##path_list (path_list_id, path, referencing_object_fullname, referenced_object_fullname, referenced_type_desc)
         SELECT  @v_path_list_id,
                 CONCAT(a.path,',',b.referenced_object_fullname),
                 a.referenced_object_fullname,
                 b.referenced_object_fullname,
                 b.referenced_type_desc
         FROM    cte_determine_referenced_object a
         INNER JOIN ##path b ON a.referenced_object_fullname = b.referencing_object_fullname
                 AND b.referenced_object_fullname IS NOT NULL
                 AND CHARINDEX(b.referenced_object_fullname, a.path) = 0;

         SET @v_row_count = @@ROWCOUNT;
         PRINT('@v_row_count: ' + CAST(@v_row_count AS VARCHAR(1000)));

         SET @v_path_list_id = @v_path_list_id + 1;

    END;

    INSERT INTO ##path_list_final (path, referenced_object_fullname, referenced_type_desc)
    SELECT  path,
            referenced_object_fullname,
            referenced_type_desc
    FROM    ##path_list r1
    WHERE   1=1 AND
            NOT EXISTS (
                SELECT 1 FROM ##path_list r2
                WHERE r2.path LIKE r1.path + ',%');

    DROP TABLE IF EXISTS ##path_list_rpt;

    SELECT id,
           REPLACE(path,',',N'   ‚û°Ô∏è   ') AS path,
           referenced_object_fullname,
           referenced_type_desc,
           (LEN(path) - LEN(REPLACE(path, ',', ''))) / LEN(',') AS depth
    INTO   ##path_list_rpt
    FROM   ##path_list_final;

    SELECT * FROM ##path_list_rpt;

END
GO

CREATE OR ALTER PROCEDURE ##temp_sp_determine_reverse_paths (@v_object_name VARCHAR(1000)) AS
BEGIN

    TRUNCATE TABLE ##path;
    TRUNCATE TABLE ##path_list;
    TRUNCATE TABLE ##path_list_final;

    INSERT INTO ##path (referencing_object_name, referencing_object_fullname, referenced_object_name, referenced_object_fullname, referenced_type_desc)
    SELECT DISTINCT
           referencing_object_name,
           referencing_object_fullname,
           referenced_object_name,
           (CASE referenced_object_fullname WHEN 'UNKNOWN' THEN NULL ELSE referenced_object_fullname END) AS referenced_object_fullname,
           referenced_type_desc
    FROM   ##sql_expression_dependencies;

    INSERT INTO ##path_list (path_list_id, path, referencing_object_fullname, referenced_object_fullname, referenced_type_desc)
    SELECT  1 AS path_list_id,
            CONCAT(referencing_object_fullname,',',referenced_object_fullname) AS path,
            referencing_object_fullname,
            referenced_object_fullname,
            referenced_type_desc
    FROM    ##path
    WHERE   1=1
            AND referenced_object_name = @v_object_name
            AND referencing_object_fullname IS NOT NULL;

    DECLARE @v_row_count INTEGER = 1;
    DECLARE @v_path_list_id INTEGER = 2;

    WHILE @v_row_count >= 1
    BEGIN
         WITH cte_determine_referencing_object AS
         (
         SELECT   path,
                  SUBSTRING(path, 1, CHARINDEX(',', path) - 1) AS referencing_object_fullname,
                  referenced_type_desc
         FROM    ##path_list
         WHERE   path_list_id = @v_path_list_id - 1
         )
         INSERT INTO ##path_list (path_list_id, path, referencing_object_fullname, referenced_object_fullname, referenced_type_desc)
         SELECT  @v_path_list_id,
                 CONCAT(b.referencing_object_fullname,',',a.path),
                 b.referencing_object_fullname,
                 a.referencing_object_fullname,
                 b.referenced_type_desc
         FROM    cte_determine_referencing_object a
         INNER JOIN ##path b ON a.referencing_object_fullname = b.referenced_object_fullname
                 AND b.referencing_object_fullname IS NOT NULL
                 AND CHARINDEX(b.referencing_object_fullname, a.path) = 0;

         SET @v_row_count = @@ROWCOUNT;
         PRINT('@v_row_count: ' + CAST(@v_row_count AS VARCHAR(1000)));

         SET @v_path_list_id = @v_path_list_id + 1;

    END;

    INSERT INTO ##path_list_final (path, referenced_object_fullname, referenced_type_desc)
    SELECT  path,
            referenced_object_fullname,
            referenced_type_desc
    FROM    ##path_list r1
    WHERE   1=1 AND
            NOT EXISTS (
                SELECT 1 FROM ##path_list r2
                WHERE r2.path LIKE r1.path + ',%'
            );

    SELECT  DISTINCT 
            id,
            REPLACE(path,',',N'   ‚¨ÖÔ∏è   ') AS [path], 
            SUBSTRING(path, 1, CHARINDEX(',', [path]) - 1) AS referencing_object_fullname,
            (LEN(path) - LEN(REPLACE(path, ',', ''))) AS depth            
    FROM    ##path_list_final

END
GO
```
